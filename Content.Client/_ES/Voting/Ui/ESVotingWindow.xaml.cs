using System.Linq;
using Content.Client.UserInterface.Controls;
using Content.Shared._ES.Voting;
using Content.Shared._ES.Voting.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;

namespace Content.Client._ES.Voting.Ui;

[GenerateTypedNameReferences]
public sealed partial class ESVotingWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    private readonly ESVoteSystem _vote;

    private List<Entity<ESVoteComponent>> _lastVotes = new();

    public event Action<Entity<ESVoteComponent>, ESVoteOption>? OnVoteChanged;

    public ESVotingWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _vote = _entityManager.System<ESVoteSystem>();
    }

    public void Update(EntityUid owner)
    {
        var votes = _vote.EnumerateVotes().ToList();

        if (votes.Count != _lastVotes.Count || votes.Intersect(_lastVotes).Count() != votes.Count)
        {
            VotesContainer.Children.Clear();
            foreach (var vote in votes)
            {
                var voteControl = new ESVoteControl
                {
                    Vote = vote,
                };
                voteControl.OnVoteChanged += (arg1, arg2) => OnVoteChanged?.Invoke(arg1, arg2);
                VotesContainer.AddChild(voteControl);
            }
        }

        _lastVotes = votes;

        foreach (var child in VotesContainer.Children)
        {
            if (child is ESVoteControl ctrl)
            {
                var comp = _entityManager.GetComponent<ESVoteComponent>(ctrl.Vote);
                ctrl.Update((ctrl.Vote, comp), owner);
            }
        }
    }
}

